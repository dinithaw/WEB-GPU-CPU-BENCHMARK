<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Stress Tester</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing libraries for advanced effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/postprocessing/EffectComposer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/postprocessing/RenderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/shaders/CopyShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/shaders/UnrealBloomShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/shaders/FXAAShader.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0b0d10;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            background-image: radial-gradient(at 20% 80%, #17101f, #0b0d10), radial-gradient(at 80% 20%, #2f1d3f, #0b0d10);
            background-size: 100% 100%;
            overflow: hidden; /* Prevent scrolling */
        }

        .container {
            max-width: 800px;
            width: 95%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card {
            background-color: rgba(45, 30, 60, 0.05);
            border-radius: 2rem;
            backdrop-filter: blur(60px);
            -webkit-backdrop-filter: blur(60px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            border: 1px solid rgba(120, 80, 140, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 15px 50px rgba(192, 132, 252, 0.8), 0 0 30px rgba(192, 132, 252, 0.6);
        }

        .canvas-container {
            width: 100%;
            position: relative;
            padding-top: 56.25%;
            margin-top: 1.5rem;
            border-radius: 1.5rem;
            overflow: hidden;
            border: 2px solid rgba(120, 80, 140, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #gpu-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        .stats-box {
            background-color: rgba(20, 15, 30, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 1rem;
            border-radius: 1rem;
            margin-top: 1.5rem;
            width: 100%;
            text-align: left;
            border: 1px dashed rgba(120, 80, 140, 0.3);
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(120, 80, 140, 0.2);
        }

        .stats-item:last-child {
            border-bottom: none;
        }

        .title {
            font-size: 2rem;
            font-weight: bold;
            color: #c084fc;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1rem;
            color: #a0aec0;
            text-align: center;
            margin-bottom: 1rem;
        }

        .button,
        .control-group select,
        .control-group input[type="range"] {
            transition: all 0.3s ease-in-out;
            border: 1px solid rgba(120, 80, 140, 0.4);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .button {
            background-color: rgba(100, 80, 120, 0.2);
            color: #e2e8f0;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
        }

        .button:hover {
            background-color: rgba(120, 100, 140, 0.4);
            transform: translateY(-4px);
            box-shadow: 0 0 25px rgba(192, 132, 252, 0.8), 0 0 10px rgba(192, 132, 252, 0.6);
        }

        .button:active {
            transform: translateY(0);
        }

        .control-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .control-group label {
            margin-bottom: 0.25rem;
            color: #a0aec0;
        }

        .control-group select {
            background-color: rgba(100, 80, 120, 0.2);
            color: #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.5rem;
            width: 100%;
        }

        .control-group select:hover {
            box-shadow: 0 0 10px rgba(192, 132, 252, 0.4);
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #c084fc;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(192, 132, 252, 0.6);
            transition: background 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #e2e8f0;
            transform: scale(1.2);
        }

        /* Responsive adjustments for a more compact layout */
        @media (max-width: 768px) {
            .card {
                padding: 1.5rem;
                border-radius: 1.5rem;
            }

            .title {
                font-size: 1.5rem;
            }

            .subtitle {
                font-size: 0.875rem;
                margin-bottom: 0.75rem;
            }

            .stats-box {
                padding: 0.75rem;
                margin-top: 1rem;
            }

            .stats-item {
                padding: 0.25rem 0;
            }

            .control-group label {
                font-size: 0.875rem;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">
    <header class="text-center mb-2 mt-4">
        <h1 class="text-4xl font-extrabold text-white tracking-wide">GPU Stress Tester</h1>
        <p class="text-lg text-gray-400 mt-1">A WebGL-powered benchmark to push your graphics processor.</p>
    </header>

    <div class="container">
        <!-- GPU Stress Test Card -->
        <div class="card">
            <h2 class="title">GPU Stress Test</h2>
            <p class="subtitle">Select a scene and adjust the settings to test your GPU performance.</p>
            <div class="flex items-center space-x-2 my-2 w-full">
                <label for="scene-select" class="text-gray-400">Scene:</label>
                <select id="scene-select" class="bg-gray-700 text-gray-200 rounded-md p-1 w-full">
                    <option value="boxes">Boxes</option>
                    <option value="spheres">Spheres</option>
                    <option value="torusKnots">Torus Knots</option>
                    <option value="particles">Particles</option>
                    <option value="wobblePlane">Wobble Plane</option>
                    <option value="complexGeometry">Complex Geometry</option>
                    <option value="dynamicLighting">Dynamic Lighting</option>
                    <option value="proceduralTerrain">Procedural Terrain</option>
                    <option value="complexInstancing">Complex Instancing</option>
                    <option value="rayMarching">Raymarching</option>
                    <option value="postProcessing">Post-Processing</option>
                </select>
            </div>

            <!-- New GPU Controls -->
            <div class="control-group">
                <label for="object-count-slider" class="text-gray-400">Object Count: <span id="object-count-label">500</span></label>
                <input type="range" id="object-count-slider" min="100" max="5000" value="500" step="100" class="w-full">
            </div>

            <div class="flex items-center self-start mb-2">
                <input type="checkbox" id="animate-camera-checkbox" class="mr-2" checked>
                <label for="animate-camera-checkbox" class="text-gray-400">Animate Camera</label>
            </div>

            <div class="canvas-container">
                <canvas id="gpu-canvas"></canvas>
            </div>
            <div class="stats-box">
                <div class="stats-item">
                    <span class="text-gray-400">FPS:</span>
                    <span id="fps-value" class="font-bold text-teal-400">0</span>
                </div>
                <div class="stats-item">
                    <span class="text-gray-400">Render Time:</span>
                    <span id="frame-time-value" class="font-bold text-teal-400">0 ms</span>
                </div>
                <div class="stats-item">
                    <span class="text-gray-400">Objects:</span>
                    <span id="object-count" class="font-bold text-gray-300">0</span>
                </div>
            </div>
            <button id="start-gpu-test" class="button mt-2">Start GPU Test</button>
        </div>
    </div>

    <script>
        // Define shaders for the raymarching scene
        const raymarchVertexShader = `
            void main() {
                gl_Position = vec4(position, 1.0);
            }
        `;

        const raymarchFragmentShader = `
            uniform float time;
            uniform vec2 resolution;

            // Signed Distance Function for a sphere
            float sphereSDF(vec3 p, float s) {
                return length(p) - s;
            }

            // Raymarching loop
            float raymarch(vec3 rayOrigin, vec3 rayDirection) {
                float totalDistance = 0.0;
                for (int i = 0; i < 100; i++) {
                    vec3 p = rayOrigin + rayDirection * totalDistance;
                    float dist = sphereSDF(p, 1.0);
                    totalDistance += dist;
                    if (dist < 0.001 || totalDistance > 100.0) break;
                }
                return totalDistance;
            }

            // Simple color from normal
            vec3 getNormal(vec3 p) {
                float d = 0.001;
                vec2 e = vec2(d, 0.0);
                return normalize(vec3(
                    sphereSDF(p + e.xyy, 1.0) - sphereSDF(p - e.xyy, 1.0),
                    sphereSDF(p + e.yxy, 1.0) - sphereSDF(p - e.yxy, 1.0),
                    sphereSDF(p + e.yyx, 1.0) - sphereSDF(p - e.yyx, 1.0)
                ));
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / min(resolution.x, resolution.y);

                vec3 cameraPosition = vec3(0.0, 0.0, -5.0);
                vec3 rayDirection = normalize(vec3(uv, 1.0));
                
                float dist = raymarch(cameraPosition, rayDirection);
                
                vec3 finalColor = vec3(0.0);
                if (dist < 100.0) {
                    vec3 hitPoint = cameraPosition + rayDirection * dist;
                    vec3 normal = getNormal(hitPoint);
                    finalColor = normal * 0.5 + 0.5;
                }
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- Global Variables and UI Elements ---
        const startGpuButton = document.getElementById('start-gpu-test');
        const sceneSelect = document.getElementById('scene-select');
        const objectCountSlider = document.getElementById('object-count-slider');
        const objectCountLabel = document.getElementById('object-count-label');
        const animateCameraCheckbox = document.getElementById('animate-camera-checkbox');

        const fpsValue = document.getElementById('fps-value');
        const frameTimeValue = document.getElementById('frame-time-value');
        const objectCountEl = document.getElementById('object-count');

        // Update object count label when slider moves
        objectCountSlider.addEventListener('input', () => {
            objectCountLabel.textContent = objectCountSlider.value;
            // If the test is running, re-initialize the scene with the new object count
            if (gpuRunning) {
                initGpuTest(sceneSelect.value);
            }
        });

        // --- GPU Stress Test Logic ---
        let gpuRunning = false;
        let gpuAnimationId = null;
        let gpuScene, gpuCamera, gpuRenderer, gpuComposer;
        let activeObjects = [];

        // Scene configurations
        const scenes = {
            boxes: {
                init: (numObjects) => {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshPhongMaterial({ color: 0x66ccff });
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
                        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 50;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.01;
                        obj.rotation.y += 0.005;
                    });
                }
            },
            spheres: {
                init: (numObjects) => {
                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffa500 });
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 40;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.01;
                        obj.position.y = Math.sin(Date.now() * 0.001 + obj.position.x) * 5;
                    });
                }
            },
            torusKnots: {
                init: (numObjects) => {
                    const geometry = new THREE.TorusKnotGeometry(3, 1, 100, 16);
                    const material = new THREE.MeshNormalMaterial();
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 150;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.005;
                    });
                }
            },
            particles: {
                init: (numParticles) => {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(numParticles * 3);
                    const colors = new Float32Array(numParticles * 3);
                    const color = new THREE.Color();

                    for (let i = 0; i < numParticles; i++) {
                        positions[i * 3 + 0] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                        color.setHSL(i / numParticles, 1.0, 0.5);
                        colors[i * 3 + 0] = color.r;
                        colors[i * 3 + 1] = color.g;
                        colors[i * 3 + 2] = color.b;
                    }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = new THREE.PointsMaterial({ size: 0.5, vertexColors: true });
                    const points = new THREE.Points(geometry, material);
                    gpuScene.add(points);
                    activeObjects.push(points);
                    gpuCamera.position.z = 100;
                    objectCountEl.textContent = numParticles;
                },
                animate: () => {
                    if (activeObjects[0]) {
                        activeObjects[0].rotation.x += 0.001;
                        activeObjects[0].rotation.y += 0.002;
                    }
                }
            },
            wobblePlane: {
                init: (numObjects) => {
                    const PLANE_SIZE = 100;
                    const PLANE_SEGMENTS = Math.floor(Math.sqrt(numObjects));
                    const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, PLANE_SEGMENTS, PLANE_SEGMENTS);
                    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    gpuScene.add(plane);
                    activeObjects.push(plane);
                    gpuCamera.position.set(0, 50, 0);
                    gpuCamera.lookAt(0, 0, 0);
                    objectCountEl.textContent = `${PLANE_SEGMENTS * PLANE_SEGMENTS} Vertices`;
                },
                animate: () => {
                    const plane = activeObjects[0];
                    if (plane) {
                        const positions = plane.geometry.attributes.position;
                        const now = Date.now() * 0.001;
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            const z = Math.sin(x * 2 + now) * Math.cos(y * 2 + now) * 2;
                            positions.setZ(i, z);
                        }
                        positions.needsUpdate = true;
                    }
                }
            },
            complexGeometry: {
                init: (numObjects) => {
                    const geometry = new THREE.IcosahedronGeometry(2, 2); // High-poly geometry
                    const material = new THREE.MeshNormalMaterial();
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 50;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.01;
                    });
                }
            },
            dynamicLighting: {
                init: (numObjects) => {
                    const actualObjects = Math.max(1, Math.floor(numObjects / 20));
                    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
                    const material = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 100 });
                    for (let i = 0; i < actualObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }

                    const lightColor = new THREE.Color(0xff0000);
                    const light = new THREE.PointLight(lightColor, 1.5, 100);
                    gpuScene.add(light);
                    activeObjects.push(light);

                    const light2 = new THREE.PointLight(0x00ff00, 1.5, 100);
                    gpuScene.add(light2);
                    activeObjects.push(light2);

                    const light3 = new THREE.PointLight(0x0000ff, 1.5, 100);
                    gpuScene.add(light3);
                    activeObjects.push(light3);
                    
                    gpuCamera.position.z = 40;
                    objectCountEl.textContent = `${actualObjects} Objects + 3 Lights`;
                },
                animate: () => {
                    const time = Date.now() * 0.001;
                    activeObjects.forEach(obj => {
                        if (obj.isMesh) {
                            obj.rotation.x += 0.005;
                            obj.rotation.y += 0.005;
                        } else if (obj.isLight) {
                            obj.position.x = Math.sin(time * 0.7) * 20;
                            obj.position.y = Math.cos(time * 0.5) * 20;
                            obj.position.z = Math.sin(time * 0.3) * 20;
                        }
                    });
                }
            },
            proceduralTerrain: {
                init: (numObjects) => {
                    const size = 100;
                    const segments = Math.floor(Math.sqrt(numObjects));
                    const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
                    const material = new THREE.MeshLambertMaterial({ color: 0x88ff88, side: THREE.DoubleSide });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    gpuScene.add(plane);
                    activeObjects.push(plane);
                    
                    const light = new THREE.DirectionalLight(0xffffff, 1);
                    light.position.set(100, 100, 50);
                    gpuScene.add(light);
                    
                    gpuCamera.position.set(0, 50, 0);
                    gpuCamera.lookAt(0, 0, 0);
                    objectCountEl.textContent = `${(segments + 1) * (segments + 1)} Vertices`;
                },
                animate: () => {
                    const plane = activeObjects[0];
                    if (plane && plane.geometry) {
                        const positions = plane.geometry.attributes.position;
                        const time = Date.now() * 0.0005;
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            const z = (Math.sin(x * 0.5 + time) + Math.sin(y * 0.5 + time)) * 5;
                            positions.setZ(i, z);
                        }
                        positions.needsUpdate = true;
                    }
                }
            },
            complexInstancing: {
                init: (numObjects) => {
                    const instancedObjects = Math.min(100000, numObjects * 10);
                    const geometry = new THREE.TorusKnotGeometry(0.5, 0.2, 50, 8);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffa500 });
                    const instancedMesh = new THREE.InstancedMesh(geometry, material, instancedObjects);
                    
                    const dummy = new THREE.Object3D();
                    for (let i = 0; i < instancedObjects; i++) {
                        dummy.position.set(
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200,
                            (Math.random() - 0.5) * 200
                        );
                        dummy.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(i, dummy.matrix);
                    }
                    
                    gpuScene.add(instancedMesh);
                    activeObjects.push(instancedMesh);
                    gpuCamera.position.z = 200;
                    objectCountEl.textContent = `${instancedObjects} Instanced Objects`;
                },
                animate: () => {
                    const instancedMesh = activeObjects[0];
                    const dummy = new THREE.Object3D();
                    const now = Date.now() * 0.001;
                    for (let i = 0; i < instancedMesh.count; i++) {
                        instancedMesh.getMatrixAt(i, dummy.matrix);
                        dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                        dummy.rotation.x += 0.01;
                        dummy.rotation.y += 0.005;
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(i, dummy.matrix);
                    }
                    instancedMesh.instanceMatrix.needsUpdate = true;
                }
            },
            rayMarching: {
                init: () => {
                    const geometry = new THREE.PlaneGeometry(2, 2);
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0.0 },
                            resolution: { value: new THREE.Vector2() }
                        },
                        vertexShader: raymarchVertexShader,
                        fragmentShader: raymarchFragmentShader
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    gpuScene.add(mesh);
                    activeObjects.push(mesh);
                    gpuCamera.position.z = 1;
                    objectCountEl.textContent = `Complex Shader`;
                },
                animate: () => {
                    const mesh = activeObjects[0];
                    if (mesh) {
                        mesh.material.uniforms.time.value = performance.now() / 1000;
                        mesh.material.uniforms.resolution.value.x = window.innerWidth;
                        mesh.material.uniforms.resolution.value.y = window.innerHeight;
                    }
                }
            },
            postProcessing: {
                init: (numObjects) => {
                    // Set a base scene to render before post-processing
                    const geometry = new THREE.SphereGeometry(1, 64, 64);
                    const material = new THREE.MeshNormalMaterial();
                    for (let i = 0; i < numObjects / 20; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 40;
                    
                    // Setup post-processing composer
                    gpuComposer = new THREE.EffectComposer(gpuRenderer);
                    gpuComposer.addPass(new THREE.RenderPass(gpuScene, gpuCamera));
                    
                    // Add an expensive bloom pass
                    const bloomPass = new THREE.UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        1.5, // strength
                        0.4, // radius
                        0.85 // threshold
                    );
                    gpuComposer.addPass(bloomPass);

                    // Add an expensive effect pass
                    const customEffect = {
                        uniforms: {
                            tDiffuse: { value: null },
                            time: { value: 0.0 }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D tDiffuse;
                            uniform float time;
                            varying vec2 vUv;

                            void main() {
                                vec2 uv = vUv;
                                vec4 color = texture2D(tDiffuse, uv);
                                float noise = fract(sin(dot(uv * time, vec2(12.9898, 78.233))) * 43758.5453);
                                color.rgb += noise * 0.1;
                                gl_FragColor = color;
                            }
                        `
                    };
                    const customPass = new THREE.ShaderPass(customEffect);
                    gpuComposer.addPass(customPass);

                    // Final render pass
                    gpuComposer.addPass(new THREE.ShaderPass(THREE.CopyShader));
                    
                    objectCountEl.textContent = `Multi-Pass Shaders`;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.005;
                    });
                    if (gpuComposer) {
                        // Animate the custom shader uniform
                        const passes = gpuComposer.passes;
                        if (passes.length > 2 && passes[2] instanceof THREE.ShaderPass) {
                            passes[2].uniforms.time.value = performance.now() / 1000;
                        }
                    }
                }
            }
        };

        function initGpuTest(sceneName) {
            // Cleanup previous scene and composer
            if (gpuScene) {
                while (gpuScene.children.length > 0) {
                    gpuScene.remove(gpuScene.children[0]);
                }
            }
            if (gpuComposer) {
                gpuComposer.dispose();
                gpuComposer = null;
            }
            activeObjects = [];

            // Scene, camera, renderer setup
            if (!gpuRenderer) {
                gpuRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gpu-canvas'), antialias: true });
            }
            if (!gpuScene) {
                gpuScene = new THREE.Scene();
            }
            if (!gpuCamera) {
                gpuCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            }
            
            gpuRenderer.setPixelRatio(window.devicePixelRatio);
            handleResize(); // Set initial size

            // Add lights for scenes that need them
            if (sceneName !== 'rayMarching') {
                const ambientLight = new THREE.AmbientLight(0x404040, 5);
                gpuScene.add(ambientLight);
            }

            // Initialize the selected scene with the current object count
            const numObjects = parseInt(objectCountSlider.value);
            if (scenes[sceneName] && scenes[sceneName].init) {
                scenes[sceneName].init(numObjects);
            }
        }

        let lastFrameTime = null;
        function gpuAnimate() {
            gpuAnimationId = requestAnimationFrame(gpuAnimate);
            const now = performance.now();
            if (lastFrameTime) {
                const delta = now - lastFrameTime;
                frameTimeValue.textContent = `${delta.toFixed(2)} ms`;
                fpsValue.textContent = `${(1000 / delta).toFixed(0)}`;
            }
            lastFrameTime = now;

            const sceneName = sceneSelect.value;
            if (scenes[sceneName] && scenes[sceneName].animate) {
                scenes[sceneName].animate();
            }
            
            // Camera animation
            if (animateCameraCheckbox.checked) {
                const time = now * 0.0002;
                gpuCamera.position.x = Math.sin(time) * 20;
                gpuCamera.position.z = Math.cos(time) * 20;
                gpuCamera.lookAt(0, 0, 0);
            }

            // Render using composer if it exists, otherwise use the renderer
            if (gpuComposer) {
                gpuComposer.render();
            } else {
                gpuRenderer.render(gpuScene, gpuCamera);
            }
        }

        function startGpuTest() {
            if (gpuRunning) {
                cancelAnimationFrame(gpuAnimationId);
                startGpuButton.textContent = 'Start GPU Test';
                gpuRunning = false;
            } else {
                const selectedScene = sceneSelect.value;
                initGpuTest(selectedScene);
                lastFrameTime = performance.now();
                gpuAnimate();
                startGpuButton.textContent = 'Stop GPU Test';
                gpuRunning = true;
            }
        }

        function handleResize() {
            const canvas = document.getElementById('gpu-canvas');
            if (canvas && gpuRenderer && gpuCamera) {
                const rect = canvas.getBoundingClientRect();
                gpuCamera.aspect = rect.width / rect.height;
                gpuCamera.updateProjectionMatrix();
                gpuRenderer.setSize(rect.width, rect.height);
                if (gpuComposer) {
                    gpuComposer.setSize(rect.width, rect.height);
                }
            }
        }
        window.addEventListener('resize', handleResize);
        startGpuButton.addEventListener('click', startGpuTest);
    </script>
</body>

</html>
