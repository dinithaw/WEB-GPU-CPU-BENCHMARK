<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Stress Test - 3D Rendering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #e0e0e0;
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #40e0d0;
        }

        .stat-label {
            color: #b0b0b0;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel h3 {
            color: #40e0d0;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .button {
            background: linear-gradient(45deg, #ff0080, #40e0d0);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            width: 100%;
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(64, 224, 208, 0.3);
        }

        .button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        .slider-group {
            margin: 10px 0;
        }

        .slider-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #40e0d0;
            cursor: pointer;
        }

        .canvas-container {
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(64, 224, 208, 0.3);
            position: relative;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
        }

        .warning {
            background: linear-gradient(45deg, #ff4444, #ff8800);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî• GPU STRESS TEST üî•</h1>
            <p>3D Rendering Performance Testing</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="fpsDisplay">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="frameTimeDisplay">0</div>
                <div class="stat-label">Frame Time (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="objectsDisplay">0</div>
                <div class="stat-label">Objects</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="trianglesDisplay">0</div>
                <div class="stat-label">Triangles</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="gpuLoadDisplay">0%</div>
                <div class="stat-label">GPU Load</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="renderCanvas"></canvas>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h3>üåå Particle Storm</h3>
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 15px;">
                    Massive particle system with physics simulation
                </p>
                <div class="slider-group">
                    <label for="particleCount">Particles: <span id="particleCountValue">10000</span></label>
                    <input type="range" id="particleCount" class="slider" min="1000" max="100000" step="1000" value="10000">
                </div>
                <button class="button" id="particleBtn" onclick="gpuTest.toggleParticles()">Start Particles</button>
            </div>

            <div class="control-panel">
                <h3>üé≤ Geometry Chaos</h3>
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 15px;">
                    Dynamic 3D geometry with complex transformations
                </p>
                <div class="slider-group">
                    <label for="geometryCount">Objects: <span id="geometryCountValue">100</span></label>
                    <input type="range" id="geometryCount" class="slider" min="50" max="1000" step="50" value="100">
                </div>
                <button class="button" id="geometryBtn" onclick="gpuTest.toggleGeometry()">Start Geometry</button>
            </div>

            <div class="control-panel">
                <h3>üíé Shader Madness</h3>
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 15px;">
                    Complex fragment shaders with heavy computations
                </p>
                <div class="slider-group">
                    <label for="shaderComplexity">Complexity: <span id="shaderComplexityValue">50</span></label>
                    <input type="range" id="shaderComplexity" class="slider" min="10" max="200" step="10" value="50">
                </div>
                <button class="button" id="shaderBtn" onclick="gpuTest.toggleShaders()">Start Shaders</button>
            </div>

            <div class="control-panel">
                <h3>‚ö° Ultimate Test</h3>
                <p style="font-size: 0.9rem; color: #888; margin-bottom: 15px;">
                    All tests combined - maximum GPU stress
                </p>
                <button class="button" id="ultimateBtn" onclick="gpuTest.toggleUltimate()">Start Ultimate Test</button>
                <button class="button" style="background: #ff4444; margin-top: 10px;" onclick="gpuTest.stopAll()">Stop All Tests</button>
            </div>
        </div>

        <div class="warning" id="warning" style="display: none;">
            ‚ö†Ô∏è HIGH GPU LOAD - Monitor system temperatures!
        </div>
    </div>

    <script>
        class GPUStressTest {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    alert('WebGL not supported!');
                    return;
                }

                this.isRunning = false;
                this.activeTests = new Set();
                this.animationId = null;
                
                this.stats = {
                    fps: 0,
                    frameTime: 0,
                    objects: 0,
                    triangles: 0,
                    gpuLoad: 0
                };

                this.frameCount = 0;
                this.lastTime = performance.now();
                this.objects = [];
                this.shaderProgram = null;
                this.particleProgram = null;
                
                this.initWebGL();
                this.setupEventListeners();
                this.logSystemInfo();
            }

            logSystemInfo() {
                const vendor = this.gl.getParameter(this.gl.VENDOR);
                const renderer = this.gl.getParameter(this.gl.RENDERER);
                const version = this.gl.getParameter(this.gl.VERSION);
                
                console.log('GPU:', renderer);
                console.log('Vendor:', vendor);
                console.log('WebGL Version:', version);
                console.log('Max Texture Size:', this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE));
            }

            initWebGL() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                this.createShaderPrograms();
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            createShaderPrograms() {
                // Basic vertex shader
                const vertexShaderSource = `
                    attribute vec4 a_position;
                    attribute vec4 a_color;
                    uniform mat4 u_matrix;
                    varying vec4 v_color;
                    
                    void main() {
                        gl_Position = u_matrix * a_position;
                        v_color = a_color;
                        gl_PointSize = 2.0;
                    }
                `;

                // Complex fragment shader
                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec4 v_color;
                    uniform float u_time;
                    uniform float u_complexity;
                    
                    float noise(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec4 color = v_color;
                        vec2 coord = gl_FragCoord.xy * 0.01;
                        
                        // Complex shader calculations
                        for(float i = 0.0; i < 100.0; i++) {
                            if(i > u_complexity) break;
                            float n = noise(coord + i * 0.1 + u_time * 0.01);
                            color.rgb += vec3(n * 0.01);
                            coord += vec2(n * 0.1);
                        }
                        
                        gl_FragColor = color;
                    }
                `;

                // Particle vertex shader
                const particleVertexSource = `
                    attribute vec4 a_position;
                    attribute vec4 a_color;
                    attribute float a_size;
                    uniform mat4 u_matrix;
                    uniform float u_time;
                    varying vec4 v_color;
                    
                    void main() {
                        vec4 pos = a_position;
                        pos.x += sin(u_time * 0.01 + a_position.y * 0.1) * 0.5;
                        pos.y += cos(u_time * 0.01 + a_position.x * 0.1) * 0.5;
                        
                        gl_Position = u_matrix * pos;
                        gl_PointSize = a_size + sin(u_time * 0.02) * 2.0;
                        v_color = a_color;
                    }
                `;

                const particleFragmentSource = `
                    precision mediump float;
                    varying vec4 v_color;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(v_color.rgb, alpha * v_color.a);
                    }
                `;

                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                this.particleProgram = this.createShaderProgram(particleVertexSource, particleFragmentSource);
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Shader program failed to link');
                    return null;
                }

                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }

            createParticleSystem() {
                const count = parseInt(document.getElementById('particleCount').value);
                const positions = [];
                const colors = [];
                const sizes = [];

                for (let i = 0; i < count; i++) {
                    // Random positions
                    positions.push(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 4
                    );

                    // Random colors
                    colors.push(
                        Math.random(),
                        Math.random() * 0.5 + 0.5,
                        1.0,
                        Math.random() * 0.8 + 0.2
                    );

                    // Random sizes
                    sizes.push(Math.random() * 8 + 2);
                }

                return {
                    type: 'particles',
                    count: count,
                    positionBuffer: this.createBuffer(new Float32Array(positions)),
                    colorBuffer: this.createBuffer(new Float32Array(colors)),
                    sizeBuffer: this.createBuffer(new Float32Array(sizes)),
                    program: this.particleProgram
                };
            }

            createGeometry() {
                const count = parseInt(document.getElementById('geometryCount').value);
                const objects = [];

                for (let i = 0; i < count; i++) {
                    // Create a simple triangle
                    const positions = [
                        Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5,
                        Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5,
                        Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5
                    ];

                    const colors = [
                        Math.random(), Math.random(), Math.random(), 1.0,
                        Math.random(), Math.random(), Math.random(), 1.0,
                        Math.random(), Math.random(), Math.random(), 1.0
                    ];

                    objects.push({
                        type: 'geometry',
                        positionBuffer: this.createBuffer(new Float32Array(positions)),
                        colorBuffer: this.createBuffer(new Float32Array(colors)),
                        program: this.shaderProgram,
                        triangles: 1
                    });
                }

                return objects;
            }

            createBuffer(data) {
                const buffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);
                return buffer;
            }

            toggleParticles() {
                if (this.activeTests.has('particles')) {
                    this.stopTest('particles');
                } else {
                    this.startTest('particles');
                }
            }

            toggleGeometry() {
                if (this.activeTests.has('geometry')) {
                    this.stopTest('geometry');
                } else {
                    this.startTest('geometry');
                }
            }

            toggleShaders() {
                if (this.activeTests.has('shaders')) {
                    this.stopTest('shaders');
                } else {
                    this.startTest('shaders');
                }
            }

            toggleUltimate() {
                if (this.activeTests.size > 0) {
                    this.stopAll();
                } else {
                    this.startTest('particles');
                    this.startTest('geometry');
                    this.startTest('shaders');
                }
            }

            startTest(testName) {
                this.activeTests.add(testName);
                
                switch(testName) {
                    case 'particles':
                        const particleSystem = this.createParticleSystem();
                        this.objects.push(particleSystem);
                        document.getElementById('particleBtn').textContent = 'Stop Particles';
                        break;
                        
                    case 'geometry':
                        const geometryObjects = this.createGeometry();
                        this.objects.push(...geometryObjects);
                        document.getElementById('geometryBtn').textContent = 'Stop Geometry';
                        break;
                        
                    case 'shaders':
                        // Shader test uses existing objects with complex shaders
                        document.getElementById('shaderBtn').textContent = 'Stop Shaders';
                        break;
                }

                if (!this.isRunning) {
                    this.startRendering();
                }

                this.updateUI();
            }

            stopTest(testName) {
                this.activeTests.delete(testName);
                
                // Remove objects of this type
                this.objects = this.objects.filter(obj => obj.type !== testName);
                
                switch(testName) {
                    case 'particles':
                        document.getElementById('particleBtn').textContent = 'Start Particles';
                        break;
                    case 'geometry':
                        document.getElementById('geometryBtn').textContent = 'Start Geometry';
                        break;
                    case 'shaders':
                        document.getElementById('shaderBtn').textContent = 'Start Shaders';
                        break;
                }

                if (this.activeTests.size === 0) {
                    this.stopRendering();
                }

                this.updateUI();
            }

            stopAll() {
                this.activeTests.clear();
                this.objects = [];
                this.stopRendering();
                
                document.getElementById('particleBtn').textContent = 'Start Particles';
                document.getElementById('geometryBtn').textContent = 'Start Geometry';
                document.getElementById('shaderBtn').textContent = 'Start Shaders';
                document.getElementById('ultimateBtn').textContent = 'Start Ultimate Test';
                
                this.updateUI();
            }

            startRendering() {
                this.isRunning = true;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.render(performance.now());
            }

            stopRendering() {
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            render(currentTime) {
                if (!this.isRunning) return;

                // Calculate FPS
                this.frameCount++;
                if (currentTime - this.lastTime >= 1000) {
                    this.stats.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.stats.frameTime = ((currentTime - this.lastTime) / this.frameCount).toFixed(1);
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                    this.updateUI();
                }

                // Clear canvas
                this.gl.clearColor(0, 0, 0.1, 1);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                // Create projection matrix
                const aspect = this.canvas.width / this.canvas.height;
                const projectionMatrix = this.createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 100.0);
                
                // Create view matrix
                const viewMatrix = this.createLookAtMatrix([0, 0, 5], [0, 0, 0], [0, 1, 0]);
                
                // Create rotation matrix
                const angle = currentTime * 0.001;
                const rotationMatrix = this.createRotationMatrix(angle);
                
                // Combine matrices
                const mvpMatrix = this.multiplyMatrices(projectionMatrix, this.multiplyMatrices(viewMatrix, rotationMatrix));

                // Render all objects
                let totalTriangles = 0;
                let totalObjects = 0;

                this.objects.forEach(obj => {
                    this.renderObject(obj, mvpMatrix, currentTime);
                    totalObjects++;
                    totalTriangles += obj.triangles || obj.count || 1;
                });

                this.stats.objects = totalObjects;
                this.stats.triangles = totalTriangles;
                this.stats.gpuLoad = Math.min(100, Math.round((totalTriangles / 1000) * (60 / Math.max(1, this.stats.fps))));

                this.animationId = requestAnimationFrame((time) => this.render(time));
            }

            renderObject(obj, mvpMatrix, time) {
                const program = obj.program;
                this.gl.useProgram(program);

                // Set uniforms
                const matrixLocation = this.gl.getUniformLocation(program, 'u_matrix');
                const timeLocation = this.gl.getUniformLocation(program, 'u_time');
                const complexityLocation = this.gl.getUniformLocation(program, 'u_complexity');

                this.gl.uniformMatrix4fv(matrixLocation, false, mvpMatrix);
                this.gl.uniform1f(timeLocation, time);
                
                if (complexityLocation && this.activeTests.has('shaders')) {
                    this.gl.uniform1f(complexityLocation, parseFloat(document.getElementById('shaderComplexity').value));
                } else if (complexityLocation) {
                    this.gl.uniform1f(complexityLocation, 10.0);
                }

                // Bind attributes
                const positionLocation = this.gl.getAttribLocation(program, 'a_position');
                const colorLocation = this.gl.getAttribLocation(program, 'a_color');
                const sizeLocation = this.gl.getAttribLocation(program, 'a_size');

                // Position attribute
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, obj.positionBuffer);
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 3, this.gl.FLOAT, false, 0, 0);

                // Color attribute
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, obj.colorBuffer);
                this.gl.enableVertexAttribArray(colorLocation);
                this.gl.vertexAttribPointer(colorLocation, 4, this.gl.FLOAT, false, 0, 0);

                // Size attribute (for particles)
                if (sizeLocation >= 0 && obj.sizeBuffer) {
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, obj.sizeBuffer);
                    this.gl.enableVertexAttribArray(sizeLocation);
                    this.gl.vertexAttribPointer(sizeLocation, 1, this.gl.FLOAT, false, 0, 0);
                }

                // Draw
                if (obj.type === 'particles') {
                    this.gl.drawArrays(this.gl.POINTS, 0, obj.count);
                } else {
                    this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
                }
            }

            setupEventListeners() {
                // Slider updates
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    document.getElementById('particleCountValue').textContent = e.target.value;
                });

                document.getElementById('geometryCount').addEventListener('input', (e) => {
                    document.getElementById('geometryCountValue').textContent = e.target.value;
                });

                document.getElementById('shaderComplexity').addEventListener('input', (e) => {
                    document.getElementById('shaderComplexityValue').textContent = e.target.value;
                });
            }

            updateUI() {
                document.getElementById('fpsDisplay').textContent = this.stats.fps;
                document.getElementById('frameTimeDisplay').textContent = this.stats.frameTime;
                document.getElementById('objectsDisplay').textContent = this.stats.objects.toLocaleString();
                document.getElementById('trianglesDisplay').textContent = this.stats.triangles.toLocaleString();
                document.getElementById('gpuLoadDisplay').textContent = this.stats.gpuLoad + '%';

                // Show warning for high load
                const warning = document.getElementById('warning');
                if (this.stats.gpuLoad > 80 || this.activeTests.size >= 3) {
                    warning.style.display = 'block';
                } else {
                    warning.style.display = 'none';
                }

                // Update ultimate button text
                if (this.activeTests.size >= 3) {
                    document.getElementById('ultimateBtn').textContent = 'Stop Ultimate Test';
                } else {
                    document.getElementById('ultimateBtn').textContent = 'Start Ultimate Test';
                }
            }

            // Matrix math utilities
            createPerspectiveMatrix(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const rangeInv = 1 / (near - far);

                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }

            createLookAtMatrix(eye, target, up) {
                const zAxis = this.normalize(this.subtract(eye, target));
                const xAxis = this.normalize(this.cross(up, zAxis));
                const yAxis = this.cross(zAxis, xAxis);

                return new Float32Array([
                    xAxis[0], yAxis[0], zAxis[0], 0,
                    xAxis[1], yAxis[1], zAxis[1], 0,
                    xAxis[2], yAxis[2], zAxis[2], 0,
                    -this.dot(xAxis, eye), -this.dot(yAxis, eye), -this.dot(zAxis, eye), 1
                ]);
            }

            createRotationMatrix(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);

                return new Float32Array([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            multiplyMatrices(a, b) {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 0;
                        for (let k = 0; k < 4; k++) {
                            result[i * 4 + j] += a[i * 4 + k] * b[k *
