<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Stress Tester</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0b0d10;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            /* New: Subtle background gradient for the frosted glass effect with purple accents */
            background-image: radial-gradient(at 20% 80%, #17101f, #0b0d10), radial-gradient(at 80% 20%, #2f1d3f, #0b0d10);
            background-size: 100% 100%;
        }

        .container {
            max-width: 800px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 2rem;
        }

        .card {
            /* More transparent and glassy */
            background-color: rgba(45, 30, 60, 0.05);
            border-radius: 2rem;
            backdrop-filter: blur(60px);
            -webkit-backdrop-filter: blur(60px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            padding: 2.5rem;
            border: 1px solid rgba(120, 80, 140, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        .card:hover {
            transform: translateY(-8px);
            /* Purple glow on hover */
            box-shadow: 0 15px 50px rgba(192, 132, 252, 0.8), 0 0 30px rgba(192, 132, 252, 0.6);
        }

        .canvas-container {
            width: 100%;
            height: 400px;
            margin-top: 1.5rem;
            border-radius: 1.5rem;
            overflow: hidden;
            border: 2px solid rgba(120, 80, 140, 0.3);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #gpu-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        .stats-box {
            background-color: rgba(20, 15, 30, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 1.5rem;
            margin-top: 2rem;
            width: 100%;
            text-align: left;
            border: 1px dashed rgba(120, 80, 140, 0.3);
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(120, 80, 140, 0.2);
        }

        .stats-item:last-child {
            border-bottom: none;
        }

        .title {
            font-size: 2rem;
            font-weight: bold;
            /* Purple accent color */
            color: #c084fc;
            text-align: center;
            margin-bottom: 1rem;
        }

        .subtitle {
            font-size: 1rem;
            color: #a0aec0;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .button,
        .control-group select,
        .control-group input[type="range"] {
            transition: all 0.3s ease-in-out;
            border: 1px solid rgba(120, 80, 140, 0.4);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .button {
            background-color: rgba(100, 80, 120, 0.2);
            color: #e2e8f0;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
        }

        .button:hover {
            background-color: rgba(120, 100, 140, 0.4);
            transform: translateY(-4px);
            box-shadow: 0 0 25px rgba(192, 132, 252, 0.8), 0 0 10px rgba(192, 132, 252, 0.6);
        }

        .button:active {
            transform: translateY(0);
        }

        .control-group {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .control-group label {
            margin-bottom: 0.5rem;
            color: #a0aec0;
        }

        /* Styling for the select and range input */
        .control-group select {
            background-color: rgba(100, 80, 120, 0.2);
            color: #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.5rem;
            width: 100%;
        }

        .control-group select:hover {
            box-shadow: 0 0 10px rgba(192, 132, 252, 0.4);
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #c084fc;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(192, 132, 252, 0.6);
            transition: background 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #e2e8f0;
            transform: scale(1.2);
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200">
    <header class="text-center mb-8 mt-4">
        <h1 class="text-4xl font-extrabold text-white tracking-wide">GPU Stress Tester</h1>
        <p class="text-lg text-gray-400 mt-2">A WebGL-powered benchmark to push your graphics processor.</p>
    </header>

    <div class="container">
        <!-- GPU Stress Test Card -->
        <div class="card">
            <h2 class="title">GPU Stress Test</h2>
            <p class="subtitle">Select a scene and adjust the settings to test your GPU performance.</p>
            <div class="flex items-center space-x-2 my-2 w-full">
                <label for="scene-select" class="text-gray-400">Scene:</label>
                <select id="scene-select" class="bg-gray-700 text-gray-200 rounded-md p-1 w-full">
                    <option value="boxes">Boxes</option>
                    <option value="spheres">Spheres</option>
                    <option value="torusKnots">Torus Knots</option>
                    <option value="particles">Particles</option>
                    <option value="wobblePlane">Wobble Plane</option>
                    <option value="complexGeometry">Complex Geometry</option>
                    <option value="dynamicLighting">Dynamic Lighting</option>
                    <option value="proceduralTerrain">Procedural Terrain</option>
                </select>
            </div>

            <!-- New GPU Controls -->
            <div class="control-group">
                <label for="object-count-slider" class="text-gray-400">Object Count: <span id="object-count-label">500</span></label>
                <input type="range" id="object-count-slider" min="100" max="5000" value="500" step="100" class="w-full">
            </div>

            <div class="flex items-center self-start mb-4">
                <input type="checkbox" id="animate-camera-checkbox" class="mr-2" checked>
                <label for="animate-camera-checkbox" class="text-gray-400">Animate Camera</label>
            </div>

            <div class="canvas-container">
                <canvas id="gpu-canvas"></canvas>
            </div>
            <div class="stats-box">
                <div class="stats-item">
                    <span class="text-gray-400">FPS:</span>
                    <span id="fps-value" class="font-bold text-teal-400">0</span>
                </div>
                <div class="stats-item">
                    <span class="text-gray-400">Render Time:</span>
                    <span id="frame-time-value" class="font-bold text-teal-400">0 ms</span>
                </div>
                <div class="stats-item">
                    <span class="text-gray-400">Objects:</span>
                    <span id="object-count" class="font-bold text-gray-300">0</span>
                </div>
            </div>
            <button id="start-gpu-test" class="button mt-4">Start GPU Test</button>
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Global Variables and UI Elements ---
        const startGpuButton = document.getElementById('start-gpu-test');
        const sceneSelect = document.getElementById('scene-select');
        const objectCountSlider = document.getElementById('object-count-slider');
        const objectCountLabel = document.getElementById('object-count-label');
        const animateCameraCheckbox = document.getElementById('animate-camera-checkbox');

        const fpsValue = document.getElementById('fps-value');
        const frameTimeValue = document.getElementById('frame-time-value');
        const objectCountEl = document.getElementById('object-count');

        // Update object count label when slider moves
        objectCountSlider.addEventListener('input', () => {
            objectCountLabel.textContent = objectCountSlider.value;
            // If the test is running, re-initialize the scene with the new object count
            if (gpuRunning) {
                initGpuTest(sceneSelect.value);
            }
        });

        // --- GPU Stress Test Logic ---
        let gpuRunning = false;
        let gpuAnimationId = null;
        let gpuScene, gpuCamera, gpuRenderer;
        let activeObjects = [];

        // Scene configurations
        const scenes = {
            boxes: {
                init: (numObjects) => {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshPhongMaterial({ color: 0x66ccff });
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
                        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 50;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.01;
                        obj.rotation.y += 0.005;
                    });
                }
            },
            spheres: {
                init: (numObjects) => {
                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({ color: 0xffa500 });
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 40;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.01;
                        obj.position.y = Math.sin(Date.now() * 0.001 + obj.position.x) * 5;
                    });
                }
            },
            torusKnots: {
                init: (numObjects) => {
                    const geometry = new THREE.TorusKnotGeometry(3, 1, 100, 16);
                    const material = new THREE.MeshNormalMaterial();
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100, (Math.random() - 0.5) * 100);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 150;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.005;
                    });
                }
            },
            particles: {
                init: (numParticles) => {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(numParticles * 3);
                    const colors = new Float32Array(numParticles * 3);
                    const color = new THREE.Color();

                    for (let i = 0; i < numParticles; i++) {
                        positions[i * 3 + 0] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

                        color.setHSL(i / numParticles, 1.0, 0.5);
                        colors[i * 3 + 0] = color.r;
                        colors[i * 3 + 1] = color.g;
                        colors[i * 3 + 2] = color.b;
                    }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = new THREE.PointsMaterial({ size: 0.5, vertexColors: true });
                    const points = new THREE.Points(geometry, material);
                    gpuScene.add(points);
                    activeObjects.push(points);
                    gpuCamera.position.z = 100;
                    objectCountEl.textContent = numParticles;
                },
                animate: () => {
                    if (activeObjects[0]) {
                        activeObjects[0].rotation.x += 0.001;
                        activeObjects[0].rotation.y += 0.002;
                    }
                }
            },
            wobblePlane: {
                init: (numObjects) => {
                    const PLANE_SIZE = 100;
                    const PLANE_SEGMENTS = Math.floor(Math.sqrt(numObjects));
                    const geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, PLANE_SEGMENTS, PLANE_SEGMENTS);
                    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    gpuScene.add(plane);
                    activeObjects.push(plane);
                    gpuCamera.position.set(0, 50, 0);
                    gpuCamera.lookAt(0, 0, 0);
                    objectCountEl.textContent = `${PLANE_SEGMENTS * PLANE_SEGMENTS} Vertices`;
                },
                animate: () => {
                    const plane = activeObjects[0];
                    if (plane) {
                        const positions = plane.geometry.attributes.position;
                        const now = Date.now() * 0.001;
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            const z = Math.sin(x * 2 + now) * Math.cos(y * 2 + now) * 2;
                            positions.setZ(i, z);
                        }
                        positions.needsUpdate = true;
                    }
                }
            },
            complexGeometry: {
                init: (numObjects) => {
                    const geometry = new THREE.IcosahedronGeometry(2, 2); // High-poly geometry
                    const material = new THREE.MeshNormalMaterial();
                    for (let i = 0; i < numObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }
                    gpuCamera.position.z = 50;
                    objectCountEl.textContent = numObjects;
                },
                animate: () => {
                    activeObjects.forEach(obj => {
                        obj.rotation.x += 0.005;
                        obj.rotation.y += 0.01;
                    });
                }
            },
            dynamicLighting: {
                init: (numObjects) => {
                    // Set a smaller number of objects for this test to focus on lighting calculations
                    const actualObjects = Math.max(1, Math.floor(numObjects / 20));
                    const geometry = new THREE.TorusGeometry(1, 0.4, 16, 100);
                    const material = new THREE.MeshPhongMaterial({ color: 0xcccccc, shininess: 100 });
                    for (let i = 0; i < actualObjects; i++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.set((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
                        gpuScene.add(mesh);
                        activeObjects.push(mesh);
                    }

                    // Add dynamic lights
                    const lightColor = new THREE.Color(0xff0000);
                    const light = new THREE.PointLight(lightColor, 1.5, 100);
                    gpuScene.add(light);
                    activeObjects.push(light);

                    const light2 = new THREE.PointLight(0x00ff00, 1.5, 100);
                    gpuScene.add(light2);
                    activeObjects.push(light2);

                    const light3 = new THREE.PointLight(0x0000ff, 1.5, 100);
                    gpuScene.add(light3);
                    activeObjects.push(light3);
                    
                    gpuCamera.position.z = 40;
                    objectCountEl.textContent = `${actualObjects} Objects + 3 Lights`;
                },
                animate: () => {
                    const time = Date.now() * 0.001;
                    activeObjects.forEach(obj => {
                        if (obj.isMesh) {
                            obj.rotation.x += 0.005;
                            obj.rotation.y += 0.005;
                        } else if (obj.isLight) {
                            // Animate lights
                            obj.position.x = Math.sin(time * 0.7) * 20;
                            obj.position.y = Math.cos(time * 0.5) * 20;
                            obj.position.z = Math.sin(time * 0.3) * 20;
                        }
                    });
                }
            },
            proceduralTerrain: {
                init: (numObjects) => {
                    const size = 100;
                    const segments = Math.floor(Math.sqrt(numObjects));
                    const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
                    const material = new THREE.MeshLambertMaterial({ color: 0x88ff88, side: THREE.DoubleSide });
                    const plane = new THREE.Mesh(geometry, material);
                    plane.rotation.x = -Math.PI / 2;
                    gpuScene.add(plane);
                    activeObjects.push(plane);
                    
                    const light = new THREE.DirectionalLight(0xffffff, 1);
                    light.position.set(100, 100, 50);
                    gpuScene.add(light);
                    
                    gpuCamera.position.set(0, 50, 0);
                    gpuCamera.lookAt(0, 0, 0);
                    objectCountEl.textContent = `${(segments + 1) * (segments + 1)} Vertices`;
                },
                animate: () => {
                    const plane = activeObjects[0];
                    if (plane && plane.geometry) {
                        const positions = plane.geometry.attributes.position;
                        const time = Date.now() * 0.0005;
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            // Simple noise function for dynamic terrain
                            const z = (Math.sin(x * 0.5 + time) + Math.sin(y * 0.5 + time)) * 5;
                            positions.setZ(i, z);
                        }
                        positions.needsUpdate = true;
                    }
                }
            }
        };

        function initGpuTest(sceneName) {
            // Cleanup previous scene
            if (gpuScene) {
                while (gpuScene.children.length > 0) {
                    gpuScene.remove(gpuScene.children[0]);
                }
            }
            activeObjects = [];

            // Scene, camera, renderer setup
            if (!gpuRenderer) {
                gpuRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gpu-canvas'), antialias: true });
            }
            if (!gpuScene) {
                gpuScene = new THREE.Scene();
            }
            if (!gpuCamera) {
                gpuCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            }
            
            gpuRenderer.setPixelRatio(window.devicePixelRatio);
            handleResize(); // Set initial size

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            gpuScene.add(ambientLight);

            // Initialize the selected scene with the current object count
            const numObjects = parseInt(objectCountSlider.value);
            if (scenes[sceneName] && scenes[sceneName].init) {
                scenes[sceneName].init(numObjects);
            }
        }

        let lastFrameTime = null;
        function gpuAnimate() {
            gpuAnimationId = requestAnimationFrame(gpuAnimate);
            const now = performance.now();
            if (lastFrameTime) {
                const delta = now - lastFrameTime;
                frameTimeValue.textContent = `${delta.toFixed(2)} ms`;
                fpsValue.textContent = `${(1000 / delta).toFixed(0)}`;
            }
            lastFrameTime = now;

            const sceneName = sceneSelect.value;
            if (scenes[sceneName] && scenes[sceneName].animate) {
                scenes[sceneName].animate();
            }
            
            // Camera animation
            if (animateCameraCheckbox.checked) {
                const time = now * 0.0002;
                gpuCamera.position.x = Math.sin(time) * 20;
                gpuCamera.position.z = Math.cos(time) * 20;
                gpuCamera.lookAt(0, 0, 0);
            }

            gpuRenderer.render(gpuScene, gpuCamera);
        }

        function startGpuTest() {
            if (gpuRunning) {
                cancelAnimationFrame(gpuAnimationId);
                startGpuButton.textContent = 'Start GPU Test';
                gpuRunning = false;
            } else {
                const selectedScene = sceneSelect.value;
                initGpuTest(selectedScene);
                lastFrameTime = performance.now();
                gpuAnimate();
                startGpuButton.textContent = 'Stop GPU Test';
                gpuRunning = true;
            }
        }

        function handleResize() {
            const canvas = document.getElementById('gpu-canvas');
            if (canvas && gpuRenderer && gpuCamera) {
                const rect = canvas.getBoundingClientRect();
                gpuCamera.aspect = rect.width / rect.height;
                gpuCamera.updateProjectionMatrix();
                gpuRenderer.setSize(rect.width, rect.height);
            }
        }
        window.addEventListener('resize', handleResize);
        startGpuButton.addEventListener('click', startGpuTest);
    </script>
</body>

</html>
