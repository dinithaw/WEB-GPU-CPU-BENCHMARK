<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Stress Test - 3D Rendering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #e0e0e0;
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.8rem;
            background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px #ff008050); }
            to { filter: drop-shadow(0 0 30px #40e0d050); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #40e0d0;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .scene-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .scene-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .scene-card:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(64, 224, 208, 0.2);
        }

        .scene-card.active {
            border-color: #40e0d0;
            box-shadow: 0 0 20px rgba(64, 224, 208, 0.3);
        }

        .scene-title {
            font-size: 1.3rem;
            color: #40e0d0;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .scene-description {
            color: #b0b0b0;
            font-size: 0.9rem;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .button {
            background: linear-gradient(45deg, #ff0080, #40e0d0);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            width: 100%;
            margin: 5px 0;
        }

        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 0, 128, 0.3);
        }

        .button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
        }

        .button.stop {
            background: linear-gradient(45deg, #ff4444, #ff6666);
        }

        .intensity-control {
            margin: 15px 0;
        }

        .intensity-control label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #40e0d0;
            cursor: pointer;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(64, 224, 208, 0.3);
            box-shadow: 0 0 30px rgba(64, 224, 208, 0.1);
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
        }

        .global-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .global-controls .button {
            width: auto;
            min-width: 150px;
        }

        .performance-graph {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .graph-title {
            color: #40e0d0;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .fps-graph {
            width: 100%;
            height: 100px;
            background: #111;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }

        .temperature-warning {
            background: linear-gradient(45deg, #ff4444, #ff8800);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî• GPU STRESS TEST üî•</h1>
            <p>Ultimate 3D Rendering Performance Testing Suite</p>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="fpsDisplay">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="frameTimeDisplay">0</div>
                <div class="stat-label">Frame Time (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="trianglesDisplay">0</div>
                <div class="stat-label">Triangles</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="drawCallsDisplay">0</div>
                <div class="stat-label">Draw Calls</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="gpuLoadDisplay">0%</div>
                <div class="stat-label">GPU Load</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="memoryDisplay">0</div>
                <div class="stat-label">GPU Memory</div>
            </div>
        </div>

        <div class="global-controls">
            <button class="button" id="startAllBtn">üöÄ Start All Scenes</button>
            <button class="button stop" id="stopAllBtn">‚èπÔ∏è Stop All</button>
            <button class="button" id="benchmarkBtn">üìä Run Benchmark</button>
        </div>

        <div class="canvas-container">
            <canvas id="renderCanvas"></canvas>
        </div>

        <div class="performance-graph">
            <div class="graph-title">Performance Monitor</div>
            <div class="fps-graph" id="fpsGraph"></div>
        </div>

        <div class="scene-controls">
            <div class="scene-card">
                <div class="scene-title">üåå Particle Galaxy</div>
                <div class="scene-description">
                    Massive particle system with gravitational effects and dynamic lighting. Tests geometry shader performance and particle rendering.
                </div>
                <div class="intensity-control">
                    <label for="particleCount">Particles: <span id="particleCountValue">50000</span></label>
                    <input type="range" id="particleCount" class="slider" min="10000" max="500000" step="10000" value="50000">
                </div>
                <button class="button" id="particleBtn">Start Particle Test</button>
            </div>

            <div class="scene-card">
                <div class="scene-title">üé≤ Dynamic Geometry</div>
                <div class="scene-description">
                    Procedurally generated and morphing 3D geometry with complex vertex operations. Stresses vertex processing and tessellation.
                </div>
                <div class="intensity-control">
                    <label for="geometryComplexity">Complexity: <span id="geometryComplexityValue">100</span></label>
                    <input type="range" id="geometryComplexity" class="slider" min="50" max="1000" step="50" value="100">
                </div>
                <button class="button" id="geometryBtn">Start Geometry Test</button>
            </div>

            <div class="scene-card">
                <div class="scene-title">üíé Advanced Shaders</div>
                <div class="scene-description">
                    Complex fragment shaders with ray tracing effects, reflections, and procedural textures. Maximum shader ALU stress test.
                </div>
                <div class="intensity-control">
                    <label for="shaderComplexity">Shader Load: <span id="shaderComplexityValue">50</span></label>
                    <input type="range" id="shaderComplexity" class="slider" min="10" max="100" step="10" value="50">
                </div>
                <button class="button" id="shaderBtn">Start Shader Test</button>
            </div>

            <div class="scene-card">
                <div class="scene-title">üåä Fluid Simulation</div>
                <div class="scene-description">
                    Real-time fluid dynamics with wave propagation and surface tension. Tests compute shader performance and memory bandwidth.
                </div>
                <div class="intensity-control">
                    <label for="fluidResolution">Resolution: <span id="fluidResolutionValue">128</span></label>
                    <input type="range" id="fluidResolution" class="slider" min="64" max="512" step="32" value="128">
                </div>
                <button class="button" id="fluidBtn">Start Fluid Test</button>
            </div>

            <div class="scene-card">
                <div class="scene-title">üî• Volumetric Effects</div>
                <div class="scene-description">
                    Volumetric lighting, fog, and fire effects with multiple render targets. Intensive fill-rate and bandwidth testing.
                </div>
                <div class="intensity-control">
                    <label for="volumeQuality">Quality: <span id="volumeQualityValue">50</span></label>
                    <input type="range" id="volumeQuality" class="slider" min="10" max="100" step="10" value="50">
                </div>
                <button class="button" id="volumeBtn">Start Volume Test</button>
            </div>

            <div class="scene-card">
                <div class="scene-title">üéØ Multi-Pass Rendering</div>
                <div class="scene-description">
                    Multiple render passes with post-processing effects, bloom, SSAO, and HDR. Tests overall rendering pipeline efficiency.
                </div>
                <div class="intensity-control">
                    <label for="renderPasses">Passes: <span id="renderPassesValue">8</span></label>
                    <input type="range" id="renderPasses" class="slider" min="4" max="16" step="2" value="8">
                </div>
                <button class="button" id="multiPassBtn">Start Multi-Pass Test</button>
            </div>
        </div>

        <div id="temperatureWarning" class="temperature-warning hidden">
            ‚ö†Ô∏è HIGH GPU LOAD DETECTED - Monitor system temperatures!
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class GPUStressTester {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                
                this.stats = {
                    fps: 0,
                    frameTime: 0,
                    triangles: 0,
                    drawCalls: 0,
                    gpuLoad: 0,
                    memory: 0
                };

                this.activeScenes = new Set();
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsHistory = [];
                this.animationId = null;
                this.isRunning = false;

                this.objects = {
                    particles: null,
                    geometry: [],
                    fluid: null,
                    volume: null,
                    multiPass: []
                };

                this.init();
                this.setupEventListeners();
                this.logSystemInfo();
            }

            init() {
                // Setup renderer
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000011);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Setup camera
                this.camera.position.set(0, 0, 50);
                this.camera.lookAt(0, 0, 0);

                // Setup lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Handle resize
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();
            }

            logSystemInfo() {
                const gl = this.renderer.getContext();
                console.log('GPU:', gl.getParameter(gl.RENDERER));
                console.log('WebGL Version:', gl.getParameter(gl.VERSION));
                console.log('Max Texture Size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));
                console.log('Max Vertex Attribs:', gl.getParameter(gl.MAX_VERTEX_ATTRIBS));
            }

            handleResize() {
                const rect = this.canvas.getBoundingClientRect();
                this.camera.aspect = rect.width / rect.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(rect.width, rect.height);
            }

            createParticleSystem() {
                if (this.objects.particles) {
                    this.scene.remove(this.objects.particles);
                }

                const particleCount = parseInt(document.getElementById('particleCount').value);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Random positions in a sphere
                    const radius = Math.random() * 30;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);

                    // Random colors
                    colors[i3] = Math.random();
                    colors[i3 + 1] = Math.random() * 0.5 + 0.5;
                    colors[i3 + 2] = 1.0;

                    // Random velocities
                    velocities[i3] = (Math.random() - 0.5) * 0.1;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true
                });

                this.objects.particles = new THREE.Points(geometry, material);
                this.scene.add(this.objects.particles);
                this.stats.triangles += particleCount;
            }

            createDynamicGeometry() {
                // Clear existing geometry
                this.objects.geometry.forEach(obj => this.scene.remove(obj));
                this.objects.geometry = [];

                const complexity = parseInt(document.getElementById('geometryComplexity').value);
                
                for (let i = 0; i < complexity; i++) {
                    // Create morphing geometry
                    const geometry = new THREE.IcosahedronGeometry(1, 2);
                    const positions = geometry.attributes.position.array;
                    
                    // Add noise to vertices
                    for (let j = 0; j < positions.length; j += 3) {
                        const noise = Math.sin(i * 0.1 + j * 0.01) * 0.3;
                        positions[j] += noise;
                        positions[j + 1] += noise * 0.5;
                        positions[j + 2] += noise * 0.3;
                    }
                    geometry.attributes.position.needsUpdate = true;
                    geometry.computeVertexNormals();

                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / complexity, 0.8, 0.6),
                        wireframe: Math.random() > 0.5,
                        transparent: true,
                        opacity: 0.7
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );
                    mesh.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    this.objects.geometry.push(mesh);
                    this.scene.add(mesh);
                }

                this.stats.triangles += complexity * 320; // Approximate triangles per icosahedron
            }

            createAdvancedShaders() {
                // Complex fragment shader with ray tracing effects
                const shaderComplexity = parseInt(document.getElementById('shaderComplexity').value);
                
                const vertexShader = `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    uniform float time;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        vUv = uv;
                        
                        vec3 pos = position;
                        pos += sin(time * 0.01 + position.x * 0.1) * normal * 0.5;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `;

                const fragmentShader = `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    uniform float time;
                    uniform float complexity;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    }
                    
                    vec3 rayTrace(vec3 origin, vec3 direction) {
                        vec3 color = vec3(0.0);
                        for(float i = 0.0; i < 50.0; i++) {
                            if(i > complexity) break;
                            vec3 p = origin + direction * i * 0.1;
                            float n = noise(p + time * 0.01);
                            color += vec3(n) * 0.02;
                        }
                        return color;
                    }
                    
                    void main() {
                        vec3 color = vec3(0.0);
                        
                        // Complex ray tracing calculation
                        vec3 rayOrigin = vPosition;
                        vec3 rayDirection = normalize(vNormal);
                        
                        color += rayTrace(rayOrigin, rayDirection);
                        color += rayTrace(rayOrigin, reflect(rayDirection, vNormal)) * 0.5;
                        
                        // Procedural patterns
                        for(float i = 0.0; i < complexity; i++) {
                            float pattern = sin(vUv.x * 20.0 + time * 0.01 + i) * 
                                          cos(vUv.y * 20.0 + time * 0.01 + i);
                            color += vec3(pattern * 0.01);
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;

                // Create multiple objects with complex shaders
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.SphereGeometry(2, 32, 32);
                    const material = new THREE.ShaderMaterial({
                        vertexShader,
                        fragmentShader,
                        uniforms: {
                            time: { value: 0 },
                            complexity: { value: shaderComplexity }
                        }
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80
                    );
                    
                    this.scene.add(mesh);
                    this.objects.geometry.push(mesh);
                }
            }

            createFluidSimulation() {
                const resolution = parseInt(document.getElementById('fluidResolution').value);
                
                // Create fluid plane with dynamic displacement
                const geometry = new THREE.PlaneGeometry(50, 50, resolution, resolution);
                const positions = geometry.attributes.position.array;
                
                // Add wave-like displacement
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    positions[i + 2] = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 2;
                }
                
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    color: 0x006699,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                this.objects.fluid = new THREE.Mesh(geometry, material);
                this.scene.add(this.objects.fluid);
                
                this.stats.triangles += resolution * resolution * 2;
            }

            createVolumetricEffects() {
                const quality = parseInt(document.getElementById('volumeQuality').value);
                
                // Create volumetric fog effect using multiple transparent planes
                for (let i = 0; i < quality; i++) {
                    const geometry = new THREE.PlaneGeometry(30, 30);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.6, 0.5, 0.3),
                        transparent: true,
                        opacity: 0.02,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const plane = new THREE.Mesh(geometry, material);
                    plane.position.z = (i - quality / 2) * 0.5;
                    plane.rotation.x = Math.PI / 2;
                    
                    this.scene.add(plane);
                    this.objects.geometry.push(plane);
                }
                
                this.stats.triangles += quality * 2;
            }

            createMultiPassRendering() {
                const passes = parseInt(document.getElementById('renderPasses').value);
                
                // Create multiple render targets and post-processing effects
                for (let i = 0; i < passes; i++) {
                    // Create geometry for each pass
                    const geometry = new THREE.BoxGeometry(3, 3, 3);
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(i / passes, 0.8, 0.6)
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        Math.cos(i / passes * Math.PI * 2) * 20,
                        Math.sin(i / passes * Math.PI * 2) * 20,
                        (Math.random() - 0.5) * 20
                    );
                    
                    this.scene.add(mesh);
                    this.objects.multiPass.push(mesh);
                }
                
                this.stats.triangles += passes * 12;
                this.stats.drawCalls += passes;
            }

            startScene(sceneName) {
                this.activeScenes.add(sceneName);
                
                switch(sceneName) {
                    case 'particles':
                        this.createParticleSystem();
                        break;
                    case 'geometry':
                        this.createDynamicGeometry();
                        break;
                    case 'shaders':
                        this.createAdvancedShaders();
                        break;
                    case 'fluid':
                        this.createFluidSimulation();
                        break;
                    case 'volume':
                        this.createVolumetricEffects();
                        break;
                    case 'multipass':
                        this.createMultiPassRendering();
                        break;
                }
                
                if (!this.isRunning) {
                    this.startRendering();
                }
                
                this.updateSceneUI();
            }

            stopScene(sceneName) {
                this.activeScenes.delete(sceneName);
                
                // Clean up objects for this scene
                switch(sceneName) {
                    case 'particles':
                        if (this.objects.particles) {
                            this.scene.remove(this.objects.particles);
                            this.objects.particles = null;
                        }
                        break;
                    case 'geometry':
                    case 'shaders':
                    case 'volume':
                    case 'multipass':
                        this.objects.geometry.forEach(obj => this.scene.remove(obj));
                        this.objects.geometry = [];
                        break;
                    case 'fluid':
                        if (this.objects.fluid) {
                            this.scene.remove(this.objects.fluid);
                            this.objects.fluid = null;
                        }
                        break;
                }
                
                if (this.activeScenes.size === 0) {
                    this.stopRendering();
                }
