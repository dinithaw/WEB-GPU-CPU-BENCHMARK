<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU & CPU Stress Test Benchmark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-panel h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.3);
        }

        .button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .slider-group {
            margin: 10px 0;
        }

        .slider-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4ecdc4;
            cursor: pointer;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #b0b0b0;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #glCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
        }

        .log {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px;
        }

        .log-info { color: #4ecdc4; }
        .log-warning { color: #ffa726; }
        .log-error { color: #ff6b6b; }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>⚡ GPU & CPU Stress Tester ⚡</h1>
            <p>Push your hardware to the limits with WebGL and JavaScript</p>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="fpsCounter">0</div>
                <div class="stat-label">FPS</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="frameTime">0</div>
                <div class="stat-label">Frame Time (ms)</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="triangleCount">0</div>
                <div class="stat-label">Triangles</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="cpuScore">0</div>
                <div class="stat-label">CPU Score</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="gpuScore">0</div>
                <div class="stat-label">GPU Score</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="temperature">--</div>
                <div class="stat-label">Thermal Load</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-panel">
                <h3>🎮 GPU Stress Test</h3>
                <button class="button" id="startGpuTest">Start GPU Test</button>
                <button class="button" id="stopGpuTest" disabled>Stop GPU Test</button>
                <div class="slider-group">
                    <label for="particleCount">Particle Count: <span id="particleCountValue">10000</span></label>
                    <input type="range" id="particleCount" class="slider" min="1000" max="100000" step="1000" value="10000">
                </div>
                <div class="slider-group">
                    <label for="complexity">Shader Complexity: <span id="complexityValue">50</span></label>
                    <input type="range" id="complexity" class="slider" min="10" max="100" step="10" value="50">
                </div>
            </div>

            <div class="control-panel">
                <h3>🧠 CPU Stress Test</h3>
                <button class="button" id="startCpuTest">Start CPU Test</button>
                <button class="button" id="stopCpuTest" disabled>Stop CPU Test</button>
                <div class="slider-group">
                    <label for="threads">Worker Threads: <span id="threadsValue">4</span></label>
                    <input type="range" id="threads" class="slider" min="1" max="16" step="1" value="4">
                </div>
                <div class="slider-group">
                    <label for="workload">Workload Intensity: <span id="workloadValue">50</span></label>
                    <input type="range" id="workload" class="slider" min="10" max="100" step="10" value="50">
                </div>
            </div>

            <div class="control-panel">
                <h3>⚡ Combined Test</h3>
                <button class="button" id="startCombinedTest">Start Combined Test</button>
                <button class="button" id="stopAllTests">Stop All Tests</button>
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgress"></div>
                </div>
                <p style="font-size: 12px; color: #888; margin-top: 10px;">
                    Combined test runs for 60 seconds
                </p>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="glCanvas"></canvas>
        </div>

        <div class="log" id="logOutput"></div>
    </div>

    <script>
        class StressTester {
            constructor() {
                this.canvas = document.getElementById('glCanvas');
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                this.isGpuRunning = false;
                this.isCpuRunning = false;
                this.animationId = null;
                this.workers = [];
                this.stats = {
                    fps: 0,
                    frameTime: 0,
                    triangles: 0,
                    cpuScore: 0,
                    gpuScore: 0
                };
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.testStartTime = 0;
                this.combinedTestDuration = 60000; // 60 seconds

                this.initWebGL();
                this.setupEventListeners();
                this.updateUI();
                this.log('System initialized', 'info');
                this.logSystemInfo();
            }

            logSystemInfo() {
                if (this.gl) {
                    const vendor = this.gl.getParameter(this.gl.VENDOR);
                    const renderer = this.gl.getParameter(this.gl.RENDERER);
                    this.log(`GPU: ${renderer} (${vendor})`, 'info');
                    this.log(`WebGL Version: ${this.gl.getParameter(this.gl.VERSION)}`, 'info');
                }
                this.log(`CPU Cores: ${navigator.hardwareConcurrency || 'Unknown'}`, 'info');
                this.log(`User Agent: ${navigator.userAgent.split(' ').pop()}`, 'info');
            }

            initWebGL() {
                if (!this.gl) {
                    this.log('WebGL not supported!', 'error');
                    return;
                }

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Vertex shader
                const vertexShaderSource = `
                    attribute vec4 a_position;
                    attribute vec4 a_color;
                    attribute float a_size;
                    uniform mat4 u_matrix;
                    uniform float u_time;
                    varying vec4 v_color;
                    varying float v_time;
                    
                    void main() {
                        vec4 pos = a_position;
                        pos.x += sin(u_time * 0.001 + a_position.y * 0.01) * 0.1;
                        pos.y += cos(u_time * 0.001 + a_position.x * 0.01) * 0.1;
                        gl_Position = u_matrix * pos;
                        gl_PointSize = a_size + sin(u_time * 0.01) * 2.0;
                        v_color = a_color;
                        v_time = u_time;
                    }
                `;

                // Fragment shader with complexity
                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec4 v_color;
                    varying float v_time;
                    uniform float u_complexity;
                    
                    float noise(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5, 0.5);
                        float dist = length(center);
                        
                        // Complex calculations based on complexity setting
                        float complexity = u_complexity / 100.0;
                        vec4 color = v_color;
                        
                        for(float i = 0.0; i < 50.0; i++) {
                            if(i > u_complexity) break;
                            float n = noise(gl_FragCoord.xy * 0.01 + i);
                            color.rgb += vec3(n * 0.02 * complexity);
                        }
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha *= sin(v_time * 0.01) * 0.5 + 0.5;
                        
                        gl_FragColor = vec4(color.rgb, alpha * v_color.a);
                    }
                `;

                this.program = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);
                this.setupBuffers();
            }

            createShaderProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    this.log('Shader program failed to link', 'error');
                    return null;
                }

                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    this.log('Shader compilation error: ' + this.gl.getShaderInfoLog(shader), 'error');
                    this.gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            setupBuffers() {
                this.updateParticles();
            }

            updateParticles() {
                const particleCount = parseInt(document.getElementById('particleCount').value);
                this.stats.triangles = particleCount * 2; // Estimate for particles

                const positions = [];
                const colors = [];
                const sizes = [];

                for (let i = 0; i < particleCount; i++) {
                    // Position
                    positions.push(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    );

                    // Color
                    colors.push(
                        Math.random(),
                        Math.random(),
                        Math.random(),
                        Math.random() * 0.8 + 0.2
                    );

                    // Size
                    sizes.push(Math.random() * 10 + 2);
                }

                // Position buffer
                this.positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);

                // Color buffer
                this.colorBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.STATIC_DRAW);

                // Size buffer
                this.sizeBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sizeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sizes), this.gl.STATIC_DRAW);

                this.particleCount = particleCount;
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            render(currentTime) {
                if (!this.isGpuRunning) return;

                // Calculate FPS
                this.frameCount++;
                if (currentTime - this.lastTime >= 1000) {
                    this.stats.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                    this.stats.frameTime = ((currentTime - this.lastTime) / this.frameCount).toFixed(2);
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }

                // Clear and setup
                this.gl.clearColor(0, 0, 0.1, 1);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                this.gl.useProgram(this.program);

                // Set uniforms
                const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');
                const matrixLocation = this.gl.getUniformLocation(this.program, 'u_matrix');
                const complexityLocation = this.gl.getUniformLocation(this.program, 'u_complexity');

                this.gl.uniform1f(timeLocation, currentTime);
                this.gl.uniform1f(complexityLocation, parseFloat(document.getElementById('complexity').value));

                // Create rotation matrix
                const angle = currentTime * 0.001;
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const matrix = new Float32Array([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
                this.gl.uniformMatrix4fv(matrixLocation, false, matrix);

                // Bind attributes
                const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
                const colorLocation = this.gl.getAttribLocation(this.program, 'a_color');
                const sizeLocation = this.gl.getAttribLocation(this.program, 'a_size');

                // Position attribute
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 3, this.gl.FLOAT, false, 0, 0);

                // Color attribute
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                this.gl.enableVertexAttribArray(colorLocation);
                this.gl.vertexAttribPointer(colorLocation, 4, this.gl.FLOAT, false, 0, 0);

                // Size attribute
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sizeBuffer);
                this.gl.enableVertexAttribArray(sizeLocation);
                this.gl.vertexAttribPointer(sizeLocation, 1, this.gl.FLOAT, false, 0, 0);

                // Draw
                this.gl.drawArrays(this.gl.POINTS, 0, this.particleCount);

                // Calculate GPU score based on performance
                this.stats.gpuScore = Math.round((this.stats.fps * this.stats.triangles) / 1000);

                this.updateUI();
                this.animationId = requestAnimationFrame((time) => this.render(time));
            }

            startGpuTest() {
                if (this.isGpuRunning) return;
                
                this.isGpuRunning = true;
                this.updateParticles();
                this.log('GPU stress test started', 'info');
                this.render(performance.now());
                
                document.getElementById('startGpuTest').disabled = true;
                document.getElementById('stopGpuTest').disabled = false;
            }

            stopGpuTest() {
                this.isGpuRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                this.log('GPU stress test stopped', 'info');
                
                document.getElementById('startGpuTest').disabled = false;
                document.getElementById('stopGpuTest').disabled = true;
            }

            startCpuTest() {
                if (this.isCpuRunning) return;

                this.isCpuRunning = true;
                const threadCount = parseInt(document.getElementById('threads').value);
                const workload = parseInt(document.getElementById('workload').value);

                this.log(`Starting CPU test with ${threadCount} threads`, 'info');

                // Create worker threads
                for (let i = 0; i < threadCount; i++) {
                    const workerCode = `
                        let running = false;
                        let score = 0;
                        
                        self.onmessage = function(e) {
                            if (e.data.command === 'start') {
                                running = true;
                                const intensity = e.data.intensity;
                                const startTime = performance.now();
                                
                                function cpuIntensiveTask() {
                                    if (!running) return;
                                    
                                    // Prime number calculation
                                    let primes = 0;
                                    const limit = intensity * 100;
                                    
                                    for (let num = 2; num <= limit; num++) {
                                        let isPrime = true;
                                        for (let i = 2; i <= Math.sqrt(num); i++) {
                                            if (num % i === 0) {
                                                isPrime = false;
                                                break;
                                            }
                                        }
                                        if (isPrime) primes++;
                                    }
                                    
                                    // Matrix multiplication
                                    const size = Math.floor(intensity / 10) + 10;
                                    const matrixA = Array(size).fill().map(() => Array(size).fill().map(() => Math.random()));
                                    const matrixB = Array(size).fill().map(() => Array(size).fill().map(() => Math.random()));
                                    const result = Array(size).fill().map(() => Array(size).fill(0));
                                    
                                    for (let i = 0; i < size; i++) {
                                        for (let j = 0; j < size; j++) {
                                            for (let k = 0; k < size; k++) {
                                                result[i][j] += matrixA[i][k] * matrixB[k][j];
                                            }
                                        }
                                    }
                                    
                                    score += primes + result[0][0];
                                    
                                    // Send progress
                                    self.postMessage({
                                        type: 'progress',
                                        score: score,
                                        primes: primes,
                                        operations: limit
                                    });
                                    
                                    if (running) {
                                        setTimeout(cpuIntensiveTask, 10);
                                    }
                                }
                                
                                cpuIntensiveTask();
                            } else if (e.data.command === 'stop') {
                                running = false;
                                self.postMessage({ type: 'stopped', finalScore: score });
                            }
                        };
                    `;

                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const worker = new Worker(URL.createObjectURL(blob));
                    
                    worker.onmessage = (e) => {
                        if (e.data.type === 'progress') {
                            this.stats.cpuScore += Math.round(e.data.score / 1000);
                        }
                    };

                    worker.postMessage({ command: 'start', intensity: workload });
                    this.workers.push(worker);
                }

                document.getElementById('startCpuTest').disabled = true;
                document.getElementById('stopCpuTest').disabled = false;
            }

            stopCpuTest() {
                if (!this.isCpuRunning) return;

                this.isCpuRunning = false;
                this.workers.forEach(worker => {
                    worker.postMessage({ command: 'stop' });
                    worker.terminate();
                });
                this.workers = [];
                this.log('CPU stress test stopped', 'info');

                document.getElementById('startCpuTest').disabled = false;
                document.getElementById('stopCpuTest').disabled = true;
            }

            startCombinedTest() {
                this.log('Starting combined stress test for 60 seconds...', 'info');
                this.testStartTime = performance.now();
                
                this.startGpuTest();
                this.startCpuTest();

                // Update progress bar
                const updateProgress = () => {
                    if (!this.isGpuRunning && !this.isCpuRunning) return;
                    
                    const elapsed = performance.now() - this.testStartTime;
                    const progress = Math.min((elapsed / this.combinedTestDuration) * 100, 100);
                    document.getElementById('testProgress').style.width = progress + '%';
                    
                    if (progress < 100) {
                        setTimeout(updateProgress, 100);
                    } else {
                        this.stopAllTests();
                        this.log('Combined test completed!', 'info');
                        document.getElementById('testProgress').style.width = '0%';
                    }
                };
                
                updateProgress();

                // Auto-stop after duration
                setTimeout(() => {
                    if (this.isGpuRunning || this.isCpuRunning) {
                        this.stopAllTests();
                        this.log('Combined test completed!', 'info');
                        document.getElementById('testProgress').style.width = '0%';
                    }
                }, this.combinedTestDuration);
            }

            stopAllTests() {
                this.stopGpuTest();
                this.stopCpuTest();
                this.log('All tests stopped', 'info');
            }

            setupEventListeners() {
                document.getElementById('startGpuTest').addEventListener('click', () => this.startGpuTest());
                document.getElementById('stopGpuTest').addEventListener('click', () => this.stopGpuTest());
                document.getElementById('startCpuTest').addEventListener('click', () => this.startCpuTest());
                document.getElementById('stopCpuTest').addEventListener('click', () => this.stopCpuTest());
                document.getElementById('startCombinedTest').addEventListener('click', () => this.startCombinedTest());
                document.getElementById('stopAllTests').addEventListener('click', () => this.stopAllTests());

                // Slider updates
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    document.getElementById('particleCountValue').textContent = e.target.value;
                    if (this.isGpuRunning) this.updateParticles();
                });

                document.getElementById('complexity').addEventListener('input', (e) => {
                    document.getElementById('complexityValue').textContent = e.target.value;
                });

                document.getElementById('threads').addEventListener('input', (e) => {
                    document.getElementById('threadsValue').textContent = e.target.value;
                });

                document.getElementById('workload').addEventListener('input', (e) => {
                    document.getElementById('workloadValue').textContent = e.target.value;
                });
            }

            updateUI() {
                document.getElementById('fpsCounter').textContent = this.stats.fps;
                document.getElementById('frameTime').textContent = this.stats.frameTime;
                document.getElementById('triangleCount').textContent = this.stats.triangles.toLocaleString();
                document.getElementById('cpuScore').textContent = Math.round(this.stats.cpuScore);
                document.getElementById('gpuScore').textContent = this.stats.gpuScore;
                
                // Simulate thermal indicator based on load
                const thermalLoad = this.isGpuRunning && this.isCpuRunning ? '🔥 High' : 
                                  this.isGpuRunning || this.isCpuRunning ? '🌡️ Medium' : '❄️ Cool';
                document.getElementById('temperature').textContent = thermalLoad;
            }

            log(message, type = 'info') {
                const logOutput = document.getElementById('logOutput');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
